//! Go code generator for lolserialize schemas.

use std::fmt::Write;

use crate::schema::*;

pub fn generate(schema: &Schema, package_name: &str) -> String {
    let generator = GoCodeGenerator::new(schema, package_name);
    generator.generate()
}

struct GoCodeGenerator<'a> {
    schema: &'a Schema,
    package_name: &'a str,
    output: String,
}

impl<'a> GoCodeGenerator<'a> {
    fn new(schema: &'a Schema, package_name: &'a str) -> Self {
        Self {
            schema,
            package_name,
            output: String::new(),
        }
    }

    fn generate(mut self) -> String {
        self.output.push_str("// Code generated by lolserialize. DO NOT EDIT.\n\n");
        writeln!(self.output, "package {}\n", self.package_name).unwrap();
        self.output.push_str("import (\n");
        self.output.push_str("\t\"encoding/json\"\n");
        self.output.push_str("\t. \"github.com/lolserialize/runtime\"\n");
        self.output.push_str(")\n\n");

        for item in &self.schema.items {
            match &item.node {
                Item::Struct(s) => self.gen_struct(s),
                Item::Message(m) => self.gen_message(m),
                Item::Enum(e) => self.gen_enum(e),
                Item::Union(u) => self.gen_union(u),
            }
            self.output.push('\n');
        }

        self.output
    }

    fn go_type(&self, ty: &Type) -> String {
        match ty {
            Type::Bool => "bool".to_string(),
            Type::U8 => "uint8".to_string(),
            Type::U16 => "uint16".to_string(),
            Type::U32 => "uint32".to_string(),
            Type::U64 => "uint64".to_string(),
            Type::I8 => "int8".to_string(),
            Type::I16 => "int16".to_string(),
            Type::I32 => "int32".to_string(),
            Type::I64 => "int64".to_string(),
            Type::F32 => "float32".to_string(),
            Type::F64 => "float64".to_string(),
            Type::String => "string".to_string(),
            Type::Array(inner) => format!("[]{}", self.go_type(&inner.node)),
            Type::Map(k, v) => format!("map[{}]{}", self.go_type(&k.node), self.go_type(&v.node)),
            Type::Named(name) => format!("*{}", name),
        }
    }

    fn go_type_optional(&self, ty: &Type) -> String {
        match ty {
            Type::Named(_) => self.go_type(ty), // Already a pointer
            _ => format!("*{}", self.go_type(ty)),
        }
    }

    fn gen_struct(&mut self, s: &Struct) {
        writeln!(self.output, "type {} struct {{", s.name.node).unwrap();

        for field in &s.fields {
            let ty = if field.node.optional {
                self.go_type_optional(&field.node.ty.node)
            } else {
                self.go_type(&field.node.ty.node)
            };
            let json_tag = if field.node.optional {
                format!(",omitempty")
            } else {
                String::new()
            };
            writeln!(self.output, "\t{} {} `json:\"{}{}\"`",
                to_pascal_case(&field.node.name.node), ty, &field.node.name.node, json_tag).unwrap();
        }

        self.output.push_str("}\n\n");

        // Generate Encode method
        writeln!(self.output, "func (s *{}) Encode(buf *[]byte) {{", s.name.node).unwrap();

        // Handle optional fields - encode presence bits first
        let optional_fields: Vec<_> = s.fields.iter().filter(|f| f.node.optional).collect();
        if !optional_fields.is_empty() {
            self.output.push_str("\t// Encode presence bits\n");
            self.output.push_str("\tpresence := []bool{");
            for (i, field) in optional_fields.iter().enumerate() {
                if i > 0 {
                    self.output.push_str(", ");
                }
                write!(self.output, "s.{} != nil", to_pascal_case(&field.node.name.node)).unwrap();
            }
            self.output.push_str("}\n");
            self.output.push_str("\tEncodePresenceBits(presence, buf)\n\n");
        }

        // Encode each field
        for field in &s.fields {
            let field_name = to_pascal_case(&field.node.name.node);
            if field.node.optional {
                writeln!(self.output, "\tif s.{} != nil {{", field_name).unwrap();
                self.encode_value(&format!("*s.{}", field_name), &field.node.ty.node, 2);
                self.output.push_str("\t}\n");
            } else {
                self.encode_value(&format!("s.{}", field_name), &field.node.ty.node, 1);
            }
        }

        self.output.push_str("}\n\n");

        // Generate Decode method
        writeln!(self.output, "func Decode{}(buf *[]byte) (*{}, error) {{", s.name.node, s.name.node).unwrap();
        writeln!(self.output, "\tvar err error").unwrap();
        writeln!(self.output, "\tresult := &{}{{}} ", s.name.node).unwrap();

        // Handle optional fields - decode presence bits first
        if !optional_fields.is_empty() {
            writeln!(self.output, "\tvar presence []bool").unwrap();
            writeln!(self.output, "\tpresence, err = DecodePresenceBits({}, buf)", optional_fields.len()).unwrap();
            self.output.push_str("\tif err != nil {\n\t\treturn nil, err\n\t}\n\n");
        }

        // Decode each field
        let mut presence_idx = 0;
        for field in &s.fields {
            let field_name = to_pascal_case(&field.node.name.node);
            if field.node.optional {
                writeln!(self.output, "\tif presence[{}] {{", presence_idx).unwrap();
                self.decode_value(&format!("result.{}", field_name), &field.node.ty.node, 2, true);
                self.output.push_str("\t}\n");
                presence_idx += 1;
            } else {
                self.decode_value(&format!("result.{}", field_name), &field.node.ty.node, 1, false);
            }
        }

        self.output.push_str("\treturn result, nil\n");
        self.output.push_str("}\n");
    }

    fn gen_message(&mut self, m: &Message) {
        writeln!(self.output, "type {} struct {{", m.name.node).unwrap();

        for field in &m.fields {
            let ty = if field.node.optional {
                self.go_type_optional(&field.node.ty.node)
            } else {
                self.go_type(&field.node.ty.node)
            };
            let json_tag = if field.node.optional {
                format!(",omitempty")
            } else {
                String::new()
            };
            writeln!(self.output, "\t{} {} `json:\"{}{}\"`",
                to_pascal_case(&field.node.name.node), ty, &field.node.name.node, json_tag).unwrap();
        }

        self.output.push_str("}\n\n");

        // Generate Encode method
        writeln!(self.output, "func (m *{}) Encode(buf *[]byte) {{", m.name.node).unwrap();

        for field in &m.fields {
            let field_name = to_pascal_case(&field.node.name.node);
            let index = field.node.index.node;

            if field.node.optional {
                writeln!(self.output, "\tif m.{} != nil {{", field_name).unwrap();
                self.encode_tagged_field(index, &format!("*m.{}", field_name), &field.node.ty.node, 2);
                self.output.push_str("\t}\n");
            } else {
                self.encode_tagged_field(index, &format!("m.{}", field_name), &field.node.ty.node, 1);
            }
        }

        self.output.push_str("\tEncodeMessageEnd(buf)\n");
        self.output.push_str("}\n\n");

        // Generate Decode method
        writeln!(self.output, "func Decode{}(buf *[]byte) (*{}, error) {{", m.name.node, m.name.node).unwrap();
        writeln!(self.output, "\tresult := &{}{{}} ", m.name.node).unwrap();

        self.output.push_str("\tfor {\n");
        self.output.push_str("\t\tindex, wireType, hasMore, err := DecodeTag(buf)\n");
        self.output.push_str("\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n");
        self.output.push_str("\t\tif !hasMore {\n\t\t\tbreak\n\t\t}\n\n");
        self.output.push_str("\t\tswitch index {\n");

        for field in &m.fields {
            let field_name = to_pascal_case(&field.node.name.node);
            let index = field.node.index.node;
            writeln!(self.output, "\t\tcase {}:", index).unwrap();
            self.decode_tagged_field(&format!("result.{}", field_name), &field.node.ty.node, 3, field.node.optional);
        }

        self.output.push_str("\t\tdefault:\n");
        self.output.push_str("\t\t\tif err := SkipByWireType(wireType, buf); err != nil {\n");
        self.output.push_str("\t\t\t\treturn nil, err\n\t\t\t}\n");
        self.output.push_str("\t\t}\n");
        self.output.push_str("\t}\n");
        self.output.push_str("\treturn result, nil\n");
        self.output.push_str("}\n");
    }

    fn gen_enum(&mut self, e: &Enum) {
        writeln!(self.output, "type {} uint32\n", e.name.node).unwrap();

        self.output.push_str("const (\n");
        for variant in &e.variants {
            writeln!(self.output, "\t{}{} {} = {}",
                e.name.node,
                to_pascal_case(&variant.node.name.node),
                e.name.node,
                variant.node.index.node
            ).unwrap();
        }
        self.output.push_str(")\n\n");

        // Generate Encode method
        writeln!(self.output, "func (e {}) Encode(buf *[]byte) {{", e.name.node).unwrap();
        self.output.push_str("\tEncodeU32(uint32(e), buf)\n");
        self.output.push_str("}\n\n");

        // Generate Decode method
        writeln!(self.output, "func Decode{}(buf *[]byte) ({}, error) {{", e.name.node, e.name.node).unwrap();
        self.output.push_str("\tv, err := DecodeU32(buf)\n");
        self.output.push_str("\tif err != nil {\n\t\treturn 0, err\n\t}\n");
        self.output.push_str("\tswitch v {\n");

        for variant in &e.variants {
            writeln!(self.output, "\tcase {}:", variant.node.index.node).unwrap();
            writeln!(self.output, "\t\treturn {}{}, nil",
                e.name.node,
                to_pascal_case(&variant.node.name.node)
            ).unwrap();
        }

        self.output.push_str("\tdefault:\n");
        self.output.push_str("\t\treturn 0, ErrUnknownEnumVariant\n");
        self.output.push_str("\t}\n");
        self.output.push_str("}\n\n");

        // Generate MarshalJSON method
        writeln!(self.output, "func (e {}) MarshalJSON() ([]byte, error) {{", e.name.node).unwrap();
        self.output.push_str("\tswitch e {\n");
        for variant in &e.variants {
            writeln!(self.output, "\tcase {}{}:", e.name.node, to_pascal_case(&variant.node.name.node)).unwrap();
            writeln!(self.output, "\t\treturn []byte(\"\\\"{}\\\"\"), nil", variant.node.name.node).unwrap();
        }
        self.output.push_str("\tdefault:\n");
        self.output.push_str("\t\treturn nil, ErrUnknownEnumVariant\n");
        self.output.push_str("\t}\n");
        self.output.push_str("}\n\n");

        // Generate UnmarshalJSON method
        writeln!(self.output, "func (e *{}) UnmarshalJSON(data []byte) error {{", e.name.node).unwrap();
        self.output.push_str("\tvar s string\n");
        self.output.push_str("\tif err := json.Unmarshal(data, &s); err != nil {\n\t\treturn err\n\t}\n");
        self.output.push_str("\tswitch s {\n");
        for variant in &e.variants {
            writeln!(self.output, "\tcase \"{}\":", variant.node.name.node).unwrap();
            writeln!(self.output, "\t\t*e = {}{}", e.name.node, to_pascal_case(&variant.node.name.node)).unwrap();
        }
        self.output.push_str("\tdefault:\n");
        self.output.push_str("\t\treturn ErrUnknownEnumVariant\n");
        self.output.push_str("\t}\n");
        self.output.push_str("\treturn nil\n");
        self.output.push_str("}\n");
    }

    fn gen_union(&mut self, u: &Union) {
        // Generate union type as interface
        writeln!(self.output, "type {} interface {{", u.name.node).unwrap();
        writeln!(self.output, "\tEncode(buf *[]byte)").unwrap();
        writeln!(self.output, "\tis{}()", u.name.node).unwrap();
        self.output.push_str("}\n\n");

        // Generate variant types
        for variant in &u.variants {
            let variant_name = format!("{}{}", u.name.node, to_pascal_case(&variant.node.name.node));

            if let Some(ref ty) = variant.node.ty {
                writeln!(self.output, "type {} struct {{", variant_name).unwrap();
                writeln!(self.output, "\tValue {}", self.go_type(&ty.node)).unwrap();
                self.output.push_str("}\n\n");
            } else {
                writeln!(self.output, "type {} struct {{}}\n", variant_name).unwrap();
            }

            // Implement interface marker
            writeln!(self.output, "func ({}) is{}() {{}}\n", variant_name, u.name.node).unwrap();

            // Encode method for variant
            writeln!(self.output, "func (v {}) Encode(buf *[]byte) {{", variant_name).unwrap();
            let index = variant.node.index.node;

            if let Some(ref ty) = variant.node.ty {
                let wire_type = self.wire_type(&ty.node);
                writeln!(self.output, "\tEncodeTag({}, {}, buf)", index, wire_type).unwrap();
                if wire_type == "WireBytes" {
                    self.output.push_str("\t// Encode length-delimited\n");
                    self.output.push_str("\tlengthBuf := []byte{}\n");
                    self.encode_value("v.Value", &ty.node, 1);
                    self.output.push_str("\tEncodeBytes(lengthBuf, buf)\n");
                } else {
                    self.encode_value("v.Value", &ty.node, 1);
                }
            } else {
                writeln!(self.output, "\tEncodeTag({}, WireUnit, buf)", index).unwrap();
            }

            self.output.push_str("}\n\n");
        }

        // Generate Decode function
        writeln!(self.output, "func Decode{}(buf *[]byte) ({}, error) {{", u.name.node, u.name.node).unwrap();
        self.output.push_str("\tindex, _, _, err := DecodeTag(buf)\n");
        self.output.push_str("\tif err != nil {\n\t\treturn nil, err\n\t}\n\n");
        self.output.push_str("\tswitch index {\n");

        for variant in &u.variants {
            let variant_name = format!("{}{}", u.name.node, to_pascal_case(&variant.node.name.node));
            writeln!(self.output, "\tcase {}:", variant.node.index.node).unwrap();

            if let Some(ref ty) = variant.node.ty {
                self.output.push_str("\t\tvar value ");
                self.output.push_str(&self.go_type(&ty.node));
                self.output.push('\n');

                let wire_type = self.wire_type(&ty.node);
                if wire_type == "WireBytes" {
                    self.output.push_str("\t\tlength, err := DecodeLEB128(buf)\n");
                    self.output.push_str("\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n");
                    self.output.push_str("\t\t_ = length // TODO: use for bounds checking\n");
                }

                self.decode_value_inline("value", &ty.node, 2);
                writeln!(self.output, "\t\treturn {}{{{}}}, nil", variant_name,
                    if self.is_named_type(&ty.node) { "value" } else { "Value: value" }).unwrap();
            } else {
                writeln!(self.output, "\t\treturn {}{{}}, nil", variant_name).unwrap();
            }
        }

        self.output.push_str("\tdefault:\n");
        self.output.push_str("\t\treturn nil, ErrUnknownUnionVariant\n");
        self.output.push_str("\t}\n");
        self.output.push_str("}\n\n");

        // Generate JSON marshaling for each variant
        for variant in &u.variants {
            let variant_name = format!("{}{}", u.name.node, to_pascal_case(&variant.node.name.node));
            let orig_name = &variant.node.name.node;

            // MarshalJSON
            writeln!(self.output, "func (v {}) MarshalJSON() ([]byte, error) {{", variant_name).unwrap();
            if variant.node.ty.is_some() {
                writeln!(self.output, "\tm := map[string]interface{{}}{{").unwrap();
                writeln!(self.output, "\t\t\"$tag\": \"{}\",", orig_name).unwrap();
                writeln!(self.output, "\t\t\"$value\": v.Value,").unwrap();
                writeln!(self.output, "\t}}").unwrap();
                writeln!(self.output, "\treturn json.Marshal(m)").unwrap();
            } else {
                // Unit variant - marshal as just the string
                writeln!(self.output, "\treturn []byte(\"\\\"{}\\\"\"), nil", orig_name).unwrap();
            }
            writeln!(self.output, "}}\n").unwrap();
        }

        // Generate UnmarshalJSON wrapper
        writeln!(self.output, "// {}JSON is a wrapper for JSON unmarshaling", u.name.node).unwrap();
        writeln!(self.output, "type {}JSON struct {{", u.name.node).unwrap();
        writeln!(self.output, "\tTag string `json:\"$tag\"`").unwrap();
        writeln!(self.output, "\tValue json.RawMessage `json:\"$value\"`").unwrap();
        writeln!(self.output, "}}\n").unwrap();

        // Helper function to unmarshal union from JSON
        writeln!(self.output, "func Unmarshal{}JSON(data []byte) ({}, error) {{", u.name.node, u.name.node).unwrap();
        writeln!(self.output, "\t// Try unit variant (just a string)").unwrap();
        writeln!(self.output, "\tvar tag string").unwrap();
        writeln!(self.output, "\tif err := json.Unmarshal(data, &tag); err == nil {{").unwrap();
        writeln!(self.output, "\t\tswitch tag {{").unwrap();
        for variant in &u.variants {
            if variant.node.ty.is_none() {
                let variant_name = format!("{}{}", u.name.node, to_pascal_case(&variant.node.name.node));
                writeln!(self.output, "\t\tcase \"{}\":", variant.node.name.node).unwrap();
                writeln!(self.output, "\t\t\treturn {}{{}}, nil", variant_name).unwrap();
            }
        }
        writeln!(self.output, "\t\t}}").unwrap();
        writeln!(self.output, "\t}}").unwrap();
        writeln!(self.output, "\t// Try tagged variant").unwrap();
        writeln!(self.output, "\tvar wrapper {}JSON", u.name.node).unwrap();
        writeln!(self.output, "\tif err := json.Unmarshal(data, &wrapper); err != nil {{").unwrap();
        writeln!(self.output, "\t\treturn nil, err").unwrap();
        writeln!(self.output, "\t}}").unwrap();
        writeln!(self.output, "\tswitch wrapper.Tag {{").unwrap();
        for variant in &u.variants {
            let variant_name = format!("{}{}", u.name.node, to_pascal_case(&variant.node.name.node));
            writeln!(self.output, "\tcase \"{}\":", variant.node.name.node).unwrap();
            if let Some(ref ty) = variant.node.ty {
                writeln!(self.output, "\t\tvar value {}", self.go_type(&ty.node)).unwrap();
                writeln!(self.output, "\t\tif err := json.Unmarshal(wrapper.Value, &value); err != nil {{").unwrap();
                writeln!(self.output, "\t\t\treturn nil, err").unwrap();
                writeln!(self.output, "\t\t}}").unwrap();
                writeln!(self.output, "\t\treturn {}{{Value: value}}, nil", variant_name).unwrap();
            } else {
                writeln!(self.output, "\t\treturn {}{{}}, nil", variant_name).unwrap();
            }
        }
        writeln!(self.output, "\tdefault:").unwrap();
        writeln!(self.output, "\t\treturn nil, ErrUnknownUnionVariant").unwrap();
        writeln!(self.output, "\t}}").unwrap();
        writeln!(self.output, "}}\n").unwrap();
    }

    fn encode_value(&mut self, value: &str, ty: &Type, indent: usize) {
        let tabs = "\t".repeat(indent);
        match ty {
            Type::Bool => writeln!(self.output, "{}EncodeBool({}, buf)", tabs, value).unwrap(),
            Type::U8 => writeln!(self.output, "{}EncodeU8({}, buf)", tabs, value).unwrap(),
            Type::U16 => writeln!(self.output, "{}EncodeU16({}, buf)", tabs, value).unwrap(),
            Type::U32 => writeln!(self.output, "{}EncodeU32({}, buf)", tabs, value).unwrap(),
            Type::U64 => writeln!(self.output, "{}EncodeU64({}, buf)", tabs, value).unwrap(),
            Type::I8 => writeln!(self.output, "{}EncodeI8({}, buf)", tabs, value).unwrap(),
            Type::I16 => writeln!(self.output, "{}EncodeI16({}, buf)", tabs, value).unwrap(),
            Type::I32 => writeln!(self.output, "{}EncodeI32({}, buf)", tabs, value).unwrap(),
            Type::I64 => writeln!(self.output, "{}EncodeI64({}, buf)", tabs, value).unwrap(),
            Type::F32 => writeln!(self.output, "{}EncodeF32({}, buf)", tabs, value).unwrap(),
            Type::F64 => writeln!(self.output, "{}EncodeF64({}, buf)", tabs, value).unwrap(),
            Type::String => writeln!(self.output, "{}EncodeString({}, buf)", tabs, value).unwrap(),
            Type::Array(inner) => {
                writeln!(self.output, "{}EncodeLEB128(uint64(len({})), buf)", tabs, value).unwrap();
                writeln!(self.output, "{}for _, item := range {} {{", tabs, value).unwrap();
                self.encode_value("item", &inner.node, indent + 1);
                writeln!(self.output, "{}}}", tabs).unwrap();
            }
            Type::Map(k, v) => {
                writeln!(self.output, "{}EncodeLEB128(uint64(len({})), buf)", tabs, value).unwrap();
                writeln!(self.output, "{}for k, v := range {} {{", tabs, value).unwrap();
                self.encode_value("k", &k.node, indent + 1);
                self.encode_value("v", &v.node, indent + 1);
                writeln!(self.output, "{}}}", tabs).unwrap();
            }
            Type::Named(_) => writeln!(self.output, "{}{}.Encode(buf)", tabs, value).unwrap(),
        }
    }

    fn decode_value(&mut self, target: &str, ty: &Type, indent: usize, optional: bool) {
        let tabs = "\t".repeat(indent);
        let (decode_call, _err_check) = self.decode_call(ty);

        if optional {
            writeln!(self.output, "{}var v {}", tabs, self.go_type(ty)).unwrap();
            writeln!(self.output, "{}v, err = {}", tabs, decode_call).unwrap();
            writeln!(self.output, "{}if err != nil {{", tabs).unwrap();
            writeln!(self.output, "{}\treturn nil, err", tabs).unwrap();
            writeln!(self.output, "{}}}", tabs).unwrap();
            writeln!(self.output, "{}{} = &v", tabs, target).unwrap();
        } else {
            writeln!(self.output, "{}{}, err = {}", tabs, target, decode_call).unwrap();
            writeln!(self.output, "{}if err != nil {{", tabs).unwrap();
            writeln!(self.output, "{}\treturn nil, err", tabs).unwrap();
            writeln!(self.output, "{}}}", tabs).unwrap();
        }
    }

    fn decode_value_inline(&mut self, target: &str, ty: &Type, indent: usize) {
        let tabs = "\t".repeat(indent);
        let (decode_call, _) = self.decode_call(ty);
        writeln!(self.output, "{}{}, err = {}", tabs, target, decode_call).unwrap();
        writeln!(self.output, "{}if err != nil {{", tabs).unwrap();
        writeln!(self.output, "{}\treturn nil, err", tabs).unwrap();
        writeln!(self.output, "{}}}", tabs).unwrap();
    }

    fn decode_call(&self, ty: &Type) -> (String, bool) {
        match ty {
            Type::Bool => ("DecodeBool(buf)".to_string(), true),
            Type::U8 => ("DecodeU8(buf)".to_string(), true),
            Type::U16 => ("DecodeU16(buf)".to_string(), true),
            Type::U32 => ("DecodeU32(buf)".to_string(), true),
            Type::U64 => ("DecodeU64(buf)".to_string(), true),
            Type::I8 => ("DecodeI8(buf)".to_string(), true),
            Type::I16 => ("DecodeI16(buf)".to_string(), true),
            Type::I32 => ("DecodeI32(buf)".to_string(), true),
            Type::I64 => ("DecodeI64(buf)".to_string(), true),
            Type::F32 => ("DecodeF32(buf)".to_string(), true),
            Type::F64 => ("DecodeF64(buf)".to_string(), true),
            Type::String => ("DecodeString(buf)".to_string(), true),
            Type::Array(_) => ("nil, nil".to_string(), true), // TODO: implement array decode
            Type::Map(_, _) => ("nil, nil".to_string(), true), // TODO: implement map decode
            Type::Named(name) => (format!("Decode{}(buf)", name), true),
        }
    }

    fn encode_tagged_field(&mut self, index: u32, value: &str, ty: &Type, indent: usize) {
        let tabs = "\t".repeat(indent);
        let wire_type = self.wire_type(ty);
        writeln!(self.output, "{}EncodeTag({}, {}, buf)", tabs, index, wire_type).unwrap();

        if wire_type == "WireBytes" {
            writeln!(self.output, "{}// TODO: encode length-delimited", tabs).unwrap();
        }

        self.encode_value(value, ty, indent);
    }

    fn decode_tagged_field(&mut self, target: &str, ty: &Type, indent: usize, optional: bool) {
        self.decode_value(target, ty, indent, optional);
    }

    fn wire_type(&self, ty: &Type) -> &'static str {
        match ty {
            Type::Bool | Type::U8 | Type::I8 => "WireFixed8",
            Type::U16 | Type::U32 | Type::U64 | Type::I16 | Type::I32 | Type::I64 => "WireVarint",
            Type::F32 => "WireFixed32",
            Type::F64 => "WireFixed64",
            Type::String | Type::Array(_) | Type::Map(_, _) => "WireBytes",
            Type::Named(_) => "WireBytes", // Structs and messages use BYTES
        }
    }

    fn is_named_type(&self, ty: &Type) -> bool {
        matches!(ty, Type::Named(_))
    }
}

fn to_pascal_case(s: &str) -> String {
    s.split('_')
        .map(|word| {
            let mut chars = word.chars();
            match chars.next() {
                None => String::new(),
                Some(first) => first.to_uppercase().collect::<String>() + chars.as_str(),
            }
        })
        .collect()
}
